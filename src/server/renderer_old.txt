import { camelToKebabCase } from "../helpers/camelToKebab";
import { ServerStateController, SubjectScope } from "./state";
import { PropertyObserver } from "../helpers/observe";

const reservedAttributes = [
    "clientOnly",
];

class ServerRenderer {
    stateController: ServerStateController;
    renderTime: number;
    onRenderFinishCallbacks: Array<() => void>
    currentElementIndex: number = 0;

    HTMLString: string = "";

    eventListenerStore: Array<{
        eleganceID: number,
        eventListeners: string[]
    }> = [];

    onHydrateFinish?: () => void;

    constructor(stateController: ServerStateController) {
        this.stateController = stateController;
        this.renderTime = 0;
        this.onRenderFinishCallbacks = []
    }

    log(content: any) {
        console.log(`%c${content}`, "font-size: 15px; color: #aaffaa;");
    }

    getOption(key: string, elementOptions: [string, any][]) {
        const value = elementOptions.find(([k]) => k === key);

        if (!value) return null;

        return value[1];
    }

    serializeEventHandler(
        attributeName: string,
        el: (...args: any) => any,
        eleganceID: number,
    ) {
        let elementInStore = this.eventListenerStore!.find(el => el.eleganceID === eleganceID);

        if (!elementInStore) {
            elementInStore = {
                eleganceID: eleganceID,
                eventListeners: [],
            };

            this.eventListenerStore!.push(elementInStore);
        }

        const eventListenerString = el.toString();

        const elAsString = `{an:"${attributeName}",el:${eventListenerString.replace(/\s+/g, '')}}`;

        elementInStore.eventListeners.push(elAsString);

        console.log(`Serialized attribute ${attributeName} for element with id: ${eleganceID}. Set to string ${eventListenerString}`);
    }

    renderElement(element: Child) {
	console.log(`Rendering: ${element}`);

        if (
            typeof element === "string" || 
            typeof element === "number" ||
            typeof element === "boolean"
        ) {
            return this.HTMLString += `${element}`;
        }

	if (Array.isArray(element)) {
	    return this.HTMLString += element.join(", ")
	}

        let elementEleganceID = null; 

        const options = Object.entries(element.options);
        const clientOnlyOption = this.getOption("clientOnly", options);

        if (clientOnlyOption === true) {
            // HANDLE CLIENT ONLY ASSIGNMENT
            console.log("CLIENT ONLY");
        }

        this.HTMLString += `<${element.tag}`;

        for (const [key, value] of options) { 
            if (reservedAttributes.includes(key)) {
		console.log(`The attribute ${key} is reserved by Elegance, and may not be used.`);

                continue;
            }

	    if (key.startsWith("on")) {
		if (!elementEleganceID) {
		    elementEleganceID = this.currentElementIndex++;

		    this.HTMLString += ` key=${elementEleganceID}`;
		}

		this.serializeEventHandler(key, value, elementEleganceID); 
	    }

	    if (typeof value === "object") {
		for (const [key, scope] of Object.entries(value.ids)) {
		    this.stateController.storeObserver(key, (scope as "local" | "global"))
		}

		continue;
	    }

	    if (typeof value === "function") {
		console.error("Functions as attributes are not supported yet.");

		continue;
	    }

	    this.HTMLString += ` ${camelToKebabCase(value)}="${value}"`;
        }

        if (!element.children) {
            this.HTMLString += "/>";
            return;
        }

        this.HTMLString += ">";

        for (const child of element.children) {
            this.renderElement(child);
        }

        this.HTMLString += `</${element.tag}>`;
    }

    setOnHydrateEnd(callback: () => void) {
	this.onHydrateFinish = callback;
    }

    async renderPage(page: Page) {
        this.renderElement(page);
    }
}

export { ServerRenderer };
