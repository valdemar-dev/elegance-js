
type ShippedComponent = {
    [key: string]: Child,
}

export const renderShippedComponentsRecursively = (
    shippedComponents: Array<ShippedComponent>
) => {
};

const camelToKebabCase = (input: string): string => {
    return input
        .replace(/([a-z])([A-Z])/g, "$1-$2")
        .toLowerCase();
}

export const anyToString = (value: any): string => {
    if (typeof value === 'function') {
	return value.toString();
    }

    if (value instanceof Promise) {
	return `Promise { <state> }`;
    }

    if (value === null) {
	return 'null';
    }

    if (value === undefined) {
	return 'undefined';
    }
    if (typeof value === 'number' || typeof value === 'string' || typeof value === 'boolean') {
	return JSON.stringify(value);
    }

    if (Array.isArray(value)) {
	return `[${value.map((item) => anyToString(item)).join(', ')}]`;
    }

    if (typeof value === 'object') {
	let className = value.constructor.name;
	if (className !== 'Object') {
	    return `${className} { ${Object.entries(value)
		.map(([key, val]) => `${key}: ${anyToString(val)}`)
		.join(', ')} }`;
	} else {
	    return `{ ${Object.entries(value)
		.map(([key, val]) => `${key}: ${anyToString(val)}`)
		.join(', ')} }`;
	}
    }

    return String(value);
}

export const createElement = (
    element: Child,
    parentInDocument: HTMLElement | DocumentFragment,
    doRenderAllChildren: boolean,
) => {
    if (typeof element === "boolean") return null;

    if (typeof element === "string") {
	const elementInDocument = document.createTextNode(element);

	parentInDocument.appendChild(elementInDocument);

	return elementInDocument;
    }

    const builtElement = element as AnyBuiltElement;

    const elementInDocument = document.createElement(builtElement.tag);

    processElementOptions(builtElement, elementInDocument, false);

    if (doRenderAllChildren) {
	const childrenLength = builtElement.children.length;

	for (let i = 0; i < childrenLength; i++) {
	    const child = builtElement.children[i];
	    if (child) {
		createElement(child, elementInDocument, true);
	    }
	}
    }

    parentInDocument.appendChild(elementInDocument);

    return elementInDocument;
}



export const assignPropertyToHTMLElement = (
    elementInDocument: HTMLElement,
    propertyName: string,
    propertyValue: any,
) =>  {
    if (!(elementInDocument instanceof HTMLElement)) {
	throw new Error(`Provided elementInDocument is not a valid HTML element. Got: ${elementInDocument}.`);
    }

    if (propertyName === 'style' && typeof propertyValue === 'object') {
	Object.assign(elementInDocument.style, propertyValue);
	return;
    }

    else if (
	propertyName.toLowerCase() in elementInDocument &&
	propertyName.startsWith("on")
    ) {
	(elementInDocument as any)[propertyName.toLowerCase()] = propertyValue;

	return;
    }

    else if (propertyName in elementInDocument) {
	(elementInDocument as any)[propertyName] = propertyValue;

	return;
    }

    else if (propertyName === 'class') {
	elementInDocument.className = propertyValue;
	return;
    }

    else if (typeof propertyValue === "function") {
	elementInDocument.setAttribute(camelToKebabCase(propertyName), propertyValue());
	return;
    }

    elementInDocument.setAttribute(camelToKebabCase(propertyName), propertyValue);
}


export const processOptionAsObserver = (
    option: Record<string, any>,
    elementInDocument: HTMLElement,
    builtElement: BuiltElement<ElementTags>,
    updateKey: string,
)  => {
    const { ids, scope, update } = option;
    const subjectValues: Array<any> = [];

    const stateController = globalThis.eleganceStateController;

    for (let i = 0; i < ids.length; i++) {
	const subjectId = ids[i];
	const subject = scope === "local" ?
	    stateController.get(subjectId) :
	    stateController.getGlobal(subjectId);

	if (!subject) continue;

	subjectValues.push(subject.get());

	const callbackFunction = async (newValue: typeof subject) => {
	    subjectValues[i] = newValue;
	    assignPropertyToHTMLElement(elementInDocument, updateKey, update(...subjectValues));
	};

	subject.observe(callbackFunction);
    }

    assignPropertyToHTMLElement(elementInDocument, updateKey, update(...subjectValues));
}

export const processElementOptions = (
    builtElement: AnyBuiltElement,
    elementInDocument: HTMLElement,
    skipObservables: boolean,
) => {
    if (!Object.hasOwn(builtElement, "getOptions")) { 
	return;
    }

    const element = builtElement as BuiltElement<ElementTags>;

    const options = element.getOptions();

    if (!options) return;

    for (const key in options) {
	if (Object.hasOwn(options, key)) {
	    const value = options[key];

	    // is an observe function call
	    // is faster than checking for instanceof PropertyObserver
	    // and it bundles less code
	    if (
		Object.hasOwn(value, "ids") &&
		Object.hasOwn(value, "update") &&
		Object.hasOwn(value, "scope")
	    ) {
		if (skipObservables) continue;

		processOptionAsObserver(value, elementInDocument, element, key);
	    }

	    assignPropertyToHTMLElement(elementInDocument, key, value);
	}
    }
}

export const updateElement = (elementInDocument: HTMLElement, element: Child) => {
    const parent = elementInDocument.parentElement;

    if (!parent) {
	throw `Cannot update element ${elementInDocument.tagName}, since it does not have a parent.`
    }

    if (typeof element === "string") {
	const textNode = document.createTextNode(element);

	parent.replaceChild(elementInDocument, textNode);

	return textNode;
    }

    if (typeof element === "boolean") {
	return null;
    }

    if (Array.isArray(element)) {
	const textNode = document.createTextNode(element.join(", "));

	parent.replaceChild(elementInDocument, textNode);

	return textNode;
    }

    const newElement = document.createElement(element.tag);
    processElementOptions(element, newElement as HTMLElement, false);

    const childrenLength = element.children.length;

    for (let i = 0; i < childrenLength; i++) {
	const child = element.children[i];
	if (child) {
	    createElement(child, newElement, true);
	}
    }

    elementInDocument.parentElement.replaceChild(newElement, elementInDocument);

    return newElement;
}

export const renderPage = (page: Page<any>) => {
    return
};
